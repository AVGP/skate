<!DOCTYPE html>
<html>
  <head>
    <title>SkateJS Documentation</title>
    <link rel="stylesheet/less" href="less/main.less">
    <link rel="stylesheet" href="bower_components/highlightjs/styles/monokai.css">
    <script src="bower_components/less/dist/less-1.6.2.js"></script>
    <script src="bower_components/highlightjs/highlight.pack.js"></script>
    <script src="bower_components/requirejs/require.js" data-main="js/main"></script>
    <script>
      require(['app'], function (app) {
        app();
      });
    </script>
  </head>
  <body>
    <a href="https://github.com/treshugart/skate"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
    <header class="main">
      <div class="container">
        <h1>Skate <a href="https://travis-ci.org/treshugart/skate"><img src="https://travis-ci.org/treshugart/skate.png?branch=master"></a></h1>
        <p>Skate is a component-based micro-framework that provides a common interface for interacting with existing and new DOM elements.</p>
      </div>
    </header>
    <ul class="toc"></ul>
    <div class="container">
      <h2 id="heading-why">Why?</h2>
      <p>Skate is heavily inspired by the <a class="external" href="https://github.com/csuwildcat/SelectorListener">SelectorListener</a> technique by Daniel Buchner. Currently, the only way to accomplish handling elements added to the DOM is by using <a class="external" href="https://developer.mozilla.org/en/docs/Web/API/MutationObserver">Mutation Observers</a> which are inherently slow and are only available in the <a class="external" href="https://developer.mozilla.org/en/docs/Web/API/MutationObserver#Browser_compatibility">greenest</a> of evergreen browsers. Contrary to Mutation Observers, this technique uses CSS animation keyframes to notify handlers about elements that are added to the DOM. This works for both new elements and existing elements alike and is very performant.</p>

      <h2 id="heading-usage">Usage</h2>
      <p>Creating a new component out of existing and new DOM elements is as easy as passing a CSS selector and component handler to a function. A component is simply a function that takes a DOM element as its only argument.</p>
      <pre code="javascript">
        var component = skate('css[selector]', function(element) {
          // your component initialisation here
        });
      </pre>


      <h2 id="components">Components</h2>
      <p>The simplest way to create a component is by simply passing a selector and a function to the <code>skate()</code> function. However, if you would like to bind to another event besides <code>ready</code> or bind to several events at once, you may also pass an object.</p>

      <p>Binding to <code>insert</code> rather than <code>ready</code>:</p>
      <pre code="javascript">
        skate('div', {
          insert: function(el) {

          }
        });
      </pre>

      <p>Binding multiple events:</p>
      <pre code="javascript">
        skate('div', {
          ready: function(el) {

          },

          insert: function(el) {

          }
        });
      </pre>

      <p>You may also specify these as separate method calls:</p>
      <pre code="javascript">
        var component = skate('div');

        component.on('ready', function(el) {

        });

        component.on('insert', function(el) {

        });

        // If you don't pass a component as the second argument
        // you must explicitly call "listen()".
        component.listen();
      </pre>

      <p>Depending on how you write your components, it may be easier for you to bulk add them.</p>
      <pre code="javascript">
        var component = skate('div');

        var component1 = function() {
          this.ready = function(el) {

          };
        };

        var component2 = {
          insert: function(el) {

          }
        };

        var component3 = function(el) {

        };

        // Explicitly bound to the "ready" event.
        component.add(new component1);

        // Explicitly bound to the "insert" event.
        component.add(component2);

        // Implicitly bound to the "ready" event.
        component.add(component3);

        // Start listening for elements.
        component.listen();
      </pre>

      <p class="alert alert-info">One thing you may have noticed is that <code>listen()</code> is explicitly called where the second argument to <code>skate()</code> is not defined. This is because, if you pass the second argument, <code>listen()</code> is implicitly called after the listeners are bound. This makes the most common use case simpler and allows you to get around that in an elegant way if necessary.</p>


      <h2 id="more">Events</h2>
      <p>All handlers are bound to events that get triggered on each skate instance.</p>

      <h3><code>ready</code></h3>
      <p>The <code>ready</code> event is triggered before an element is shown in the DOM. This is the default event if implicitly binding.</p>

      <h3><code>insert</code></h3>
      <p>The <code>insert</code> event is triggered after an element is shown in the DOM.</p>

      <h3><code>remove</code></h3>
      <p>The <code>remove</code> event is triggered after an element is removed from the DOM.</p>


      <h2 id="heading-compatibility">Compatibility</h2>
      <p>Works in all <em>evergreen browsers</em> that <a class="external" href="http://caniuse.com/#feat=css-animation">support CSS animation</a> and falls back to using <a class="external" href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events">deprecated mutation events</a> in <strong>IE9</strong>.</p>


      <h2 id="heading-examples">Examples</h2>

      <h3 id="heading-integrating-frameworks">Integrating Frameworks</h3>
      <p>If you like frameworks like Knockout, you can organise the setup logic into a component.</p>
      <pre code="javascript">
        skate('[model]', function(el) {
          //ko.applyBindings(window[el.getAttribute('model')], el);
        });
      </pre>
      <p>Then you can declaratively activate it on the element of your choice.</p>
      <pre code="html">
        <script>
          window.myModel = {
            //hello: ko.observable()
          };
        </script>

        <p model="myModel">Hello, <span data-bind="text: hello"></span>!</p>
      </pre>

      <h3 id="heading-templating">Templating</h3>
      <p>You can even create components that will render templates.</p>
      <pre code="javascript">
        skate('[template]', function(el) {
          var temp = Handlebars.compile(document.getElementById(el.getAttribute('template')));
          var data = window[el.getAttribute('template-data')] || {};
          el.innerHTML = temp(data);
        });
      </pre>
      <pre code="html">
        <script type="text/javascript">
          window.context = {
            hello: 'World'
          };
        </script>

        <script type="text/handlebars" id="hello">
          Hello, {{hello}}!
        </script>

        <div template="hello" template-data="context"></div>
      </pre>

      <h3 id="heading-nesting-components">Nesting Components</h3>
      <p>Since components activate once they hit the DOM, this means you can nest components within each other and they just work.</p>
      <pre code="html">
        <tabs>
          <tab pane="tab1">Tab 1</tab>
          <tab pane="tab2">Tab 2</tab>
          <pane tab="tab1">Tab 1 content.</pane>
          <pane tab="tab2">Tab 2 content.</pane>
        </tabs>
      </pre>
      <p>Your selector places restrictions on whether a component is valid within a given hierarchy.</p>
      <pre code="javascript">
        skate('tabs > tab', function() {
          // get tabby with it
        });

        skate('tabs > pane', function() {
          // cause some pane
        });
      </pre>
    </div>

    <footer>
      <div class="container">
        Made with <i icon="heart"></i> by <a class="external" href="http://treshugart.github.io">Trey Shugart</a>
      </div>
    </footer>
  </body>
</html>