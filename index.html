<!DOCTYPE html>
<html lang="en">
  <head>
    <title>SkateJS</title>
    <link rel="stylesheet/less" href="less/main.less">
    <link rel="stylesheet" href="bower_components/highlightjs/styles/monokai.css">
    <script src="bower_components/less/dist/less-1.6.2.js"></script>
    <script src="bower_components/highlightjs/highlight.pack.js"></script>
    <script src="bower_components/requirejs/require.js" data-main="js/main"></script>
  </head>
  <body>
    <a href="https://github.com/treshugart/skate"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
    <header class="main">
      <div class="container-fluid">
        <h1>Skate <a href="https://travis-ci.org/treshugart/skate"><img src="https://travis-ci.org/treshugart/skate.png?branch=master"></a></h1>
        <p>Skate is a web component library that allows you to define behaviour for pre-defined and custom HTML elements.</p>
      </div>
    </header>

    <div class="container-fluid">
      <section class="col-md-3">
        <ul class="toc"></ul>
      </section>

      <section class="col-md-9">
        <h2 id="heading-installing">Installing</h2>
        <p>You can install Skate using <a class="external" href="http://bower.io/">Bower</a> or by downloading the source from the <a class="external" href="https://github.com/treshugart/skate">repository</a>.</p>
        <pre code="bash">
          bower install skate
        </pre>


        <h2 id="heading-usage">Usage</h2>
        <p>Creating a new component out of existing and new DOM elements is as easy as passing a CSS selector and a component definition.</p>
        <pre code="javascript">
          skate('input[type="date"]', function() {
            // "date"
            console.log(this.type);
          });
        </pre>


        <h3 id="heading-usage-advanced">Advanced</h3>
        <p>A basic component may simply be a function. However, you can specify options and lifecycle callbacks as illustrated below.</p>
        <pre code="javascript">
          skate('p', {
            // Specify an object of properties and methods that should be
            // applied to the DOM element. Defaults to an empty object.
            extend: {},

            // Whether or not to automatically start listening. If false, then
            // you must manually call listen() on the Skate instance. Defaults
            // to true.
            listen: true,

            // Called prior to showing the element. Not supplied by default.
            // "this" inside the function refers to the DOM element. The "done"
            // parameter is optional, and if specified in the argument list, it
            // indicates that execution is async and it must be called to
            // continue the execution of the lifecycle callbacks.
            ready: function(done) {
              done();
            },

            // Called after the element is shown in the DOM. Not supplied by
            // default. "this" inside the function refers to the DOM element.
            insert: function() {

            },

            // Called after the element is removed from the DOM. Not supplied
            // by default. "this" inside the function refers to the DOM
            // element.
            remove: function() {

            }
          });
        </pre>
        <p class="alert alert-info">The second argument will be normalised to an object and will be merged with <code>skate.defaults</code>.</p>


        <p class="alert alert-info">A component's lifecycle callbacks are based on the lifecycle callbacks in the <a class="external" href="http://www.w3.org/TR/components-intro/#lifecycle-callbacks">Web Components Specification</a>.</p>


        <h3 id="heading-usage-custom-methods-and-properties">Custom Methods and Properties</h3>
        <p>As documented above, you can specify custom methods and properties on your DOM element.</p>
        <pre code="javascript">
          skate('dialog#my-dialog', {
            ready: function() {
              $(this).hide();
            },

            extend: {
              speed: 250,

              show: function() {
                $(this).fadeIn(this.speed);
                return this;
              },

              hide: function() {
                $(this).fadeOut(this.speed);
                return this;
              }
            }
          });
        </pre>
        <pre code="html">
          <dialog id="my-dialog">My dialog.</dialog>
        </pre>
        <pre code="javascript">
          document.getElementById('my-dialog').show();
        </pre>


        <h3 id="heading-usage-ready-vs-insert">Ready vs Insert</h3>
        <p>By default if you only pass a function handler as the first argument to <code>skate()</code> it will be bound to the <code>insert</code> callback. When you specify a <code>ready</code> callback, the element is hidden prior to calling <code>ready</code> and then shown just before <code>insert</code> is called so that you can alter the element's structure if need be. This isn't the default behaviour because it isn't recommended that you couple your HTML to your components. Rather, you should have a component that renders your HTML and your other components can augment the behaviour of what already exists in the DOM.</p>


        <h3 id="heading-usage-async">Handling Async Stuff in the Ready Callback</h3>
        <p>There may be situations where you need do something async in your ready callback and you don't want it to show and call <code>insert()</code> before everything finishes. If you define a second argument to the <code>ready()</code> callback it passes in a function that you can call to continue execution.
        <pre code="javascript">
          skate('selector', {
            ready: function(element, done) {
              setTimeout(function() {
                done();
              }, 1000);
            }
          });
        </pre>


        <h3 id="heading-usage-replacement">Replacing the Existing Element</h3>
        <p>If you want to replace the existing element all you have to do is pass a new element to the <code>done()</code> callback.</p>
        <pre code="javascript">
          skate('x-custom-element', {
            ready: function(element, done) {
              done(document.createElement('div'));
            }
          });
        </pre>


        <h3 id="heading-usage-api">API</h3>
        <p>Skate makes certain methods and properties available globally:</p>
        <pre code="javascript">
          // Object of default options that are used to initialse each component.
          skate.defaults;

          // Array of registered components.
          // These may or may not be listening.
          skate.instances;

          // Destroys by deafening and unregistering all registered components.
          // Can be very useful in tests in a teardown hook.
          skate.destroy();
        </pre>
        <p>Skate returns an instance which you can call methods on and get information from.</p>
        <pre code="javascript">
          // The adapter that is currently being used to listen for changes.
          component.adapter;

          // Contains an array of DOM elements which are currently bound to the component.
          component.elements;

          // Returns whether or not the component is listening for DOM elements.
          component.listening;

          // A requestAnimationFrame or setTimeout reference that listens for DOM
          // elements being removed.
          component.removeListener;

          // The selector that was used to define the component.
          component.selector;

          // Tells the component to stop listening if it is.
          component.deafen();

          // Tells the component to start listening if it isn't.
          component.listen();
        </pre>


        <h2 id="heading-synchronous-initialisation">Synchronous Initialisation</h2>
        <p>Inherently, Skate works asyncrhonously when initialising elements. For example the following isn't reliable:</p>
        <pre code="javascript">
          skate('div', function() {
            ready: function() {
              this.textContent = 'testing';
            }
          });

          var div = document.createElement('div');
          document.body.appendChild(div);

          if (div.textContent === 'testing') {
            // do your stuff here
          }
        </pre>
        <p>To ensure that the element is initialised when you want it to be, simply pass it to the skate function:</p>
        <pre code="javascript">
          skate(div);
          // now do your stuff with it
        </pre>
        <p>This doesn't just work with elements, you can pass in anything that is traversable or a selector:</p>
        <pre code="javascript">
          skate(domElement);
          skate([domElement, domElement]);
          skate(domElement.childNodes);
          skate(document.querySelectorAll('select.multiple.elements'));
          skate('select.multiple.elements');
        </pre>


        <h2 id="heading-compatibility">Compatibility</h2>
        <p>IE9+ and all evergreens.</p>


        <h2 id="heading-caveats">Caveats</h2>
        <p>Behind the scenes, CSS animations are used to notify the handlers when a new element exists. If your element has a <code>display</code> of <code>none</code>, animations will not fire causing this technique to fail. If you need to hide your element using <code>display: none</code>, then you may do so inside the <code>ready</code> callback.</p>


        <h2 id="heading-examples">Examples</h2>
        <p>You can do pretty much anything you want with skate from building a simple date picker to building an entire framework like Polymer. The following examples cover a range of ideas that are possible.</p>


        <h3 id="heading-examples-hello">Hello World</h3>
        <p>In the obligatory Hello World example, we write a component that takes the value of the <code>hello</code> property to print out "Hello, World!"</p>
        <pre code="javascript">
          skate('[hello]', function(el) {
            el.textContent = 'Hello, ' + el.getAttribute('hello') + '!';
          });
        </pre>
        <pre code="html">
          <p hello="World"></p>
        </pre>


        <h3 id="heading-examples-amd">Dynamic AMD Invocation</h3>
        <p>The following example shows how you can create a component which loads another component and then creates a new instance which applies that loaded component.</p>
        <pre code="javascript">
          // Keep track of which modules are loaded so that we don't load and
          // initialise the same module more than once.
          var loaded = [];

          skate('[module]', function(el, done) {
            var path = el.getAttribute('module');
            var alreadyLoaded = loaded.indexOf(path) !== -1;

            // We don't want to load the module more than once since after
            // loading, a new component is created that will automatically
            // initialise any new elements with the module that was loaded
            // in this component.
            if (alreadyLoaded) {
              return;
            }

            // Get the module and create a new component which will automatically
            // register any new elements that want the same component.
            require([path], function(module) {
              skate('[module="' + path + '"]', module);
              done();
            });
          });
        </pre>
        <p>You can then write HTML to dynamically load a component which is subsequently applied to your existing element.</p>
        <pre code="html">
          <p module="hello/world" hello="World"></p>
        </pre>
        <p>In <code>hello/world.js</code>:</p>
        <pre code="javascript">
          skate('[hello]', function(el) {
            el.textContent = 'Hello, ' + el.getAttribute('hello') + '!';
          });
        </pre>


        <h3 id="heading-examples-ko">Automatically Binding KnockoutJS</h3>
        <p>Knockout is a pretty cool framework, but unfortuately it can't autobind itself. With Skate, we can automate that process.</p>
        <pre code="javascript">
          skate('[ko]', function(el) {
            ko.applyBindings(window[el.getAttribute('ko')], el);
          });
        </pre>
        <p>Having your model in the global namespace may not be the best idea, but for the sake of brevity here it is:</p>
        <pre code="javascript">
          window.myAwesomeViewModel = {
            hello: 'World'
          };
        </pre>
        <p>All you've got to do then is tell your element which model you want to bind it to.</p>
        <pre code="html">
          <p ko="myAwesomeViewModel">Hello, <span data-bind="text: hello"></span>!</p>
        </pre>
      </section>
    </div>

    <footer>
      <div class="container">
        Made with <i icon="heart"></i> by <a class="external" href="http://treshugart.github.io">Trey Shugart</a>
      </div>
    </footer>
  </body>
</html>
